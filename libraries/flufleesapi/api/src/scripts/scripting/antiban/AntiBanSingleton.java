package scripts.scripting.antiban;

import scripts.data.structures.bag.BagSingleton;
import org.tribot.api.Clicking;
import org.tribot.api.General;
import org.tribot.api.Timing;
import org.tribot.api.input.Mouse;
import org.tribot.api.interfaces.Clickable07;
import org.tribot.api.interfaces.Positionable;
import org.tribot.api.util.abc.ABCUtil;
import org.tribot.api2007.*;
import org.tribot.api2007.types.RSItem;
import org.tribot.api2007.types.RSPlayer;

/*
  @author Fluffee, adapted from Einstein's AntiBan class.
 */

@SuppressWarnings({"unused", "WeakerAccess"})
public class AntiBanSingleton {

    // Instance manipulation
    private static AntiBanSingleton instance;

    private AntiBanSingleton() {
        General.useAntiBanCompliance(true);
        this.runPercentage = ABC.generateRunActivation();
        this.eatPercentage = ABC.generateEatAtHP();
    }

    public static synchronized AntiBanSingleton get() {
        if (instance == null) {
            instance = new AntiBanSingleton();
            return instance;
        } else {
            return instance;
        }
    }

    // Anti-Ban Compliance Utility v2 instance
    private final ABCUtil ABC = new ABCUtil();

    private boolean printDebug = false, clientDebug = true, isSleeping = false;

    private int resourcesWon = 0;

    private int resourcesLost = 0;

    private int runPercentage;

    private int eatPercentage;

    private int lastReactionTime = 0;

    private double abcMultiplier = 1;

    /**
     * Destroys the current instance of ABCUtil and stops all anti-ban threads.
     * Call this at the end of your script.
     */
    public void destroy() {
        ABC.close();
    }

    /**
     * Increments the amount of resources won by 1.
     */
    public void incrementResourcesWon() {
        this.resourcesWon++;
    }

    /**
     * Increments the amount of resources lost by 1.
     */
    public void incrementResourcesLost() {
        this.resourcesLost++;
    }

    public int getResourcesWon() {
        return resourcesWon;
    }

    public int getResourcesLost() {
        return resourcesLost;
    }

    public int getRunPercentage() {
        return runPercentage;
    }

    public int getEatPercentage() {
        return eatPercentage;
    }

    public int getLastReactionTime() {
        return lastReactionTime;
    }

    public void setLastReactionTime(int lastReactionTime) {
        this.lastReactionTime = lastReactionTime;
    }

    public boolean isPrintDebug() {
        return printDebug;
    }

    public void setPrintDebug(boolean printDebug) {
        this.printDebug = printDebug;
    }

    public boolean isClientDebug() {
        return clientDebug;
    }

    public void setClientDebug(boolean clientDebug) {
        this.clientDebug = clientDebug;
    }

    public double getAbcMultiplier() {
        return abcMultiplier;
    }

    public void setAbcMultiplier(double abcMultiplier) {
        this.abcMultiplier = abcMultiplier;
    }

    /**
     * Sleeps for the reaction time generated by ABCUtil, multiplied by the multiplier.
     * Note that this method uses a special sleeping method from ABCUtil that allows the ABC2 background thread to interrupt the sleep when needed.
     */
    public void sleepReactionTime() {
        final int reaction_time = (int) (this.lastReactionTime * this.abcMultiplier);
        print("Reaction time: " + reaction_time + "ms.");
        this.isSleeping = true;
        try {
            BagSingleton.getInstance().addOrUpdate("scriptStatus", "ABC2 Sleep");
            ABC.sleep(reaction_time);
        } catch (InterruptedException e) {
            print("Background thread interrupted sleep");
        }
        this.isSleeping = false;
    }

    public void resolveTimedActions() {
        if (ABC.shouldCheckTabs()) {
            print("Checking tabs.");
            ABC.checkTabs();
        }
        if (ABC.shouldCheckXP()) {
            print("Checking xp.");
            ABC.checkXP();
        }
        if (ABC.shouldExamineEntity()) {
            print("Examining entity.");
            ABC.examineEntity();
        }
        if (ABC.shouldMoveMouse()) {
            print("Moving mouse.");
            ABC.moveMouse();
        }
        if (ABC.shouldPickupMouse()) {
            print("Picking up mouse.");
            ABC.pickupMouse();
        }
        if (ABC.shouldRightClick()) {
            print("Right clicking.");
            ABC.rightClick();
        }
        if (ABC.shouldRotateCamera()) {
            print("Rotating camera.");
            ABC.rotateCamera();
        }
        if (ABC.shouldLeaveGame()) {
            print("Leaving game.");
            ABC.leaveGame();
        }
    }

    /**
     * Generates reaction time using bit flags.
     *
     * @param waitingTime - the amount of time the script was waiting for (e.g. amount of time spent cutting down a tree)
     * @return the generated reaction time in ms
     */
    public int generateReactionTime(int waitingTime, boolean underAttack) {
        long menuOpenOption = ABC.shouldOpenMenu() && ABC.shouldHover() ? ABCUtil.OPTION_MENU_OPEN : 0;
        long hoverOption = ABC.shouldHover() ? ABCUtil.OPTION_HOVERING : 0;
        long underAttackOption = underAttack ? ABCUtil.OPTION_UNDER_ATTACK : 0;
        return ABC.generateReactionTime(ABC.generateBitFlags(waitingTime, menuOpenOption, hoverOption, underAttackOption));
    }

    /**
     * Generates supporting tracking information using bit flags.
     * This method should be called right after clicking something that will require the player to wait for a while.
     *
     * @param estimatedTime for the action to complete (e.g. amount of time spent cutting down a tree)
     */
    public void generateSupportingTrackerInfo(int estimatedTime, boolean underAttack) {
        long underAttackOption = underAttack ? ABCUtil.OPTION_UNDER_ATTACK : 0;
        long hoveringOption = ABC.shouldHover() ? ABCUtil.OPTION_HOVERING : 0;
        long menuOpenOption = ABC.shouldHover() && ABC.shouldOpenMenu() ? ABCUtil.OPTION_MENU_OPEN : 0;
        ABC.generateTrackers(ABC.generateBitFlags(estimatedTime, hoveringOption, menuOpenOption, underAttackOption));
    }

    /**
     * Activates run.
     * No action is taken if run is already enabled or the current run energy is less than the value returned by ABCUtil.
     *
     * @return True if run was enabled, false otherwise.
     */
    public boolean activateRun() {
        if (Game.getRunEnergy() >= this.runPercentage && !Game.isRunOn() && Options.setRunEnabled(true)) {
            print("Enabled run at " + this.runPercentage + "%");
            this.runPercentage = ABC.generateRunActivation();
            return true;
        }
        return false;
    }

    /**
     * Eats/cocktails an item in your inventory with the specified name if your current HP percent is less than or equal to the value generated by ABCUtil.
     * Note that if there is any delay/lag that is longer than 3000 milliseconds between the time the gnomebowls/drink was clicked and when your players HP is
     * changed the tracker will not be reset and you will have to reset it manually.
     *
     * @param option The option to click the gnomebowls/drink with (this is normally "Eat" or "Drink").
     *               Input an empty string to have the method attempt to find the correct option automatically. Note that this is not guaranteed to execute properly if an
     *               empty string is inputted.
     * @param name   The name of the gnomebowls or drink.
     * @return True if the gnomebowls/drink was successfully eaten/drank, false otherwise.
     * @see #eat(java.lang.String, org.tribot.api2007.types.RSItem)
     */
    public boolean eat(String option, final String name) {
        RSItem food = null;
        if (Inventory.getCount(name) > 0) {
            food = Inventory.find(name)[0];
        }
        return eat(option, food);
    }

    /**
     * Eats/cocktails an item in your inventory with the specified ID if your current HP percent is less than or equal to the value generated by ABCUtil.
     * Note that if there is any delay/lag that is longer than 3000 milliseconds between the time the gnomebowls/drink was clicked and when your players HP is
     * changed the tracker will not be reset and you will have to reset it manually.
     *
     * @param option The option to click the gnomebowls/drink with (this is normally "Eat" or "Drink").
     *               Input an empty string to have the method attempt to find the correct option automatically. Note that this is not guaranteed to execute
     *               properly if an empty string is inputted.
     * @param id     The ID of the gnomebowls or drink.
     * @return True if the gnomebowls/drink was successfully eaten/drank, false otherwise.
     * @see #eat(java.lang.String, org.tribot.api2007.types.RSItem)
     */
    public boolean eat(String option, final int id) {
        RSItem food = null;
        if (Inventory.getCount(id) > 0) {
            food = Inventory.find(id)[0];
        }
        return eat(option, food);
    }

    /**
     * Eats/cocktails the item specified if your current HP percent is less than or equal to the value generated by ABCUtil.
     * Note that if there is any delay/lag that is longer than 3000 milliseconds between the time the gnomebowls/drink was clicked and when your players HP is
     * changed the tracker will not be reset and you will have to reset it manually.
     *
     * @param option The option to click the gnomebowls/drink with (this is normally "Eat" or "Drink").
     *               Input an empty string to have the method attempt to find the correct option automatically. Note that this is not guaranteed to execute
     *               properly if an empty string is inputted.
     * @param item   The item to eat or drink.
     * @return True if the gnomebowls/drink was successfully eaten/drank, false otherwise.
     */
    public boolean eat(String option, RSItem item) {
        final int current_hp = Combat.getHPRatio();
        if (option == null || item == null || current_hp > this.eatPercentage) {
            return false;
        }

        if (option.isEmpty()) {
            String[] actions = item.actions;
            for (String action : actions) {
                if (action.contains("Eat") || action.contains("Drink")) {
                    option = action;
                    break;
                }
            }
        }
        if (!option.isEmpty() && Clicking.click(option, item)) {
            print("Ate food at " + this.eatPercentage + "%");
            if (Timing.waitCondition(() -> {
                General.sleep(200, 400);
                return Combat.getHPRatio() > current_hp;
            }, 3000)) {
                this.eatPercentage = ABC.generateEatAtHP();
                return true;
            }
        }
        return false;
    }

    /**
     * Eats/cocktails an item in your inventory with the specified ID if your current HP percent is less than or equal to the value generated by ABCUtil.
     * Note that if there is any delay/lag that is longer than 3000 milliseconds between the time the gnomebowls/drink was clicked and when your players HP is
     * changed the tracker will not be reset and you will have to reset it manually.
     *
     * @param option The option to click the gnomebowls/drink with (this is normally "Eat" or "Drink").
     *               Input an empty string to have the method attempt to find the correct option automatically. Note that this is not guaranteed to execute
     *               properly if an empty string is inputted.
     * @param name   The name of the item to eat
     * @return True if the item was successfully eaten/drank, false otherwise.
     * @see #eat(java.lang.String, org.tribot.api2007.types.RSItem)
     */
    public boolean eatToApproximateFull(String option, String name, int variance) {
        int itemID = -1;
        if (Inventory.getCount(name) > 0) {
            itemID = Inventory.find(name)[0].getID();
        }
        return eatToApproximateFull(option, itemID, variance);
    }

    public boolean eatToApproximateFull(String option, int itemID, int variance) {
        if (option == null || itemID == -1 || Inventory.getCount(itemID) < 1 || option.isEmpty()) {
            return false;
        }
        RSPlayer player = Player.getRSPlayer();
        final double final_hp = (double) (100 - variance) / 100;
        if (player.getHealthPercent() <= this.eatPercentage) {
            while (player.getHealthPercent() < final_hp) {
                General.sleep(300);
                if (Inventory.getCount(itemID) < 1) {
                    return false;
                }
                RSItem item = Inventory.find(itemID)[0];
                final double current_hp = player.getHealthPercent();
                Clicking.click(option, item);
                Timing.waitCondition(() -> {
                    General.sleep(200, 400);
                    return player.getHealthPercent() > current_hp;
                }, General.random(3000, 5000));
            }
            print("Ate food at " + this.eatPercentage + "%");
            this.eatPercentage = ABC.generateEatAtHP();
            return true;
        }
        return false;
    }

    /**
     * Hovers the next object, must be reset manually. Object to hover must be passed.
     *
     * @param target - Clickable07 to hover
     */
    public void hoverNextObject(final Clickable07 target) {
        if (!ABC.shouldHover() || !Mouse.isInBounds()) {
            return;
        }
        target.hover();
    }

    public void openMenuObject(final Clickable07 target) {
        if (!ABC.shouldOpenMenu()) {
            return;
        }
        Mouse.click(3);
    }

    /**
     * Checks to see if the player should switch resources.
     * Note that this method will only return correctly if you have been tracking the resources you have won and lost.
     * Note also that you must create the check time in your script and reset it accordingly.
     * e.g. to check if you should switch resources, you should check the following condition:
     * <code>Timing.currentTimeMillis() >= check_time && AntiBan.shouldSwitchResources()</code>
     *
     * @param player_count The amount of players gathering resources near you.
     * @return True if your player should switch resources, false otherwise.
     */
    public boolean shouldSwitchResources(int player_count) {
        return ((double) (this.resourcesWon + this.resourcesLost) / (double) this.resourcesWon) < 50.0 && ABC.shouldSwitchResources(player_count);
    }

    /**
     * Gets the next target that should be interacted with from the specified list of targets.
     *
     * @param targets The targets to choose from.
     * @param <T>     The generic type.
     * @return The target to interact with.
     */
    public <T extends Positionable> T selectNextTarget(T[] targets) {
        return (T) ABC.selectNextTarget(targets);
    }

    /**
     * Sends the specified message to the system print stream with the [ABC2] tag.
     *
     * @param message The message to print.
     */
    private void print(Object message) {
        if (!this.printDebug) {
            return;
        } else if (this.clientDebug) {
            General.println("[Antiban] " + message);
        } else {
            System.out.println("[Antiban] " + message);
        }
    }

    public boolean shouldEat() {
        if (Combat.getHPRatio() <= eatPercentage) {
            ABC.generateEatAtHP();
            return true;
        }
        return false;
    }

    public boolean isSleeping() {
        return isSleeping;
    }
}
